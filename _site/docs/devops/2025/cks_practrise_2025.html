<!-- _layouts/default.html -->
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CKS认证考试实战指南 - Pizicai's Tech Blog</title>
    <meta name="description" content="全面解析CKS认证考试要点、核心概念及实战技巧">
    
    <!-- SEO 标签 -->
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>CKS认证考试实战指南 | Pizicai’s Tech Blog</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="CKS认证考试实战指南" />
<meta name="author" content="Pizicai" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="全面解析CKS认证考试要点、核心概念及实战技巧" />
<meta property="og:description" content="全面解析CKS认证考试要点、核心概念及实战技巧" />
<link rel="canonical" href="http://localhost:4000/docs/devops/2025/cks_practrise_2025.html" />
<meta property="og:url" content="http://localhost:4000/docs/devops/2025/cks_practrise_2025.html" />
<meta property="og:site_name" content="Pizicai’s Tech Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-15T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CKS认证考试实战指南" />
<meta name="twitter:site" content="@pizicaiman" />
<meta name="twitter:creator" content="@Pizicai" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pizicai"},"dateModified":"2025-01-15T00:00:00+08:00","datePublished":"2025-01-15T00:00:00+08:00","description":"全面解析CKS认证考试要点、核心概念及实战技巧","headline":"CKS认证考试实战指南","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/docs/devops/2025/cks_practrise_2025.html"},"url":"http://localhost:4000/docs/devops/2025/cks_practrise_2025.html"}</script>
<!-- End Jekyll SEO tag -->

    
    <!-- 代码高亮 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    
    <style>
      /* 基础样式 */
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        line-height: 1.5;
        color: #24292e;
        margin: 0;
      }
      
      .container {
        max-width: 1800px;
        margin: 0 auto;
        padding: 0 1rem;
      }
      
      header {
        border-bottom: 1px solid #e1e4e8;
        background-color: white;
        position: sticky;
        top: 0;
        z-index: 100;
      }
      
      .header-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 0;
      }
      
      .site-title {
        font-size: 1.5rem;
        font-weight: 600;
        color: #24292e;
        text-decoration: none;
      }
      
      nav ul {
        display: flex;
        list-style: none;
        gap: 1.5rem;
      }
      
      nav a {
        text-decoration: none;
        color: #586069;
        font-weight: 500;
        transition: color 0.2s;
      }
      
      nav a:hover {
        color: #0366d6;
      }
      
      main {
        min-height: calc(100vh - 120px);
        padding: 2rem 0;
      }
      
      footer {
        border-top: 1px solid #e1e4e8;
        padding: 2rem 0;
        text-align: center;
        color: #6a737d;
        font-size: 0.9rem;
      }
      
      @media (max-width: 768px) {
        .header-content {
          flex-direction: column;
          gap: 1rem;
        }
        
        nav ul {
          flex-wrap: wrap;
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="container">
        <div class="header-content">
          <a href="/" class="site-title">Pizicai's Tech Blog</a>
          <nav>
            <ul>
              
                <li>
                  <a href="/" 
                     class="">
                    首页
                  </a>
                </li>
              
                <li>
                  <a href="/docs/devops/" 
                     class="">
                    DevOps
                  </a>
                </li>
              
                <li>
                  <a href="/docs/llm/" 
                     class="">
                    LLM
                  </a>
                </li>
              
                <li>
                  <a href="/docs/web3/" 
                     class="">
                    Web3
                  </a>
                </li>
              
                <li>
                  <a href="/docs/" 
                     class="">
                    文档
                  </a>
                </li>
              
                <li>
                  <a href="/about/" 
                     class="">
                    关于
                  </a>
                </li>
              
            </ul>
          </nav>
        </div>
      </div>
    </header>
    
    <main>
      <div class="container">
        <div class="doc-page">
  <article class="doc-content">
    <h1>CKS认证考试实战指南</h1>
    
    <div class="doc-meta">
      
        <span class="doc-date">更新时间: 2025-01-15</span>
      
      
      
        <span class="doc-category">分类: devops</span>
      
    </div>
    
    <div class="doc-body">
      <h1 id="cks-certified-kubernetes-security-specialist-认证实战指南">CKS (Certified Kubernetes Security Specialist) 认证实战指南</h1>

<h2 id="目录">目录</h2>

<ol>
  <li><a href="#考试概述">考试概述</a></li>
  <li><a href="#核心知识点">核心知识点</a></li>
  <li><a href="#实战案例">实战案例</a></li>
  <li><a href="#学习路线">学习路线</a></li>
  <li><a href="#考试技巧">考试技巧</a></li>
</ol>

<h2 id="考试概述">考试概述</h2>

<h3 id="基本信息">基本信息</h3>

<ul>
  <li>考试时长：2小时</li>
  <li>题目数量：15-20道</li>
  <li>及格分数：67%</li>
  <li>考试环境：Kubernetes v1.26</li>
  <li>证书有效期：3年</li>
</ul>

<h3 id="考试范围">考试范围</h3>

<p><img src="image.png" alt="alt text" />
<a href="https://blog.csdn.net/weixin_45651006/article/details/134135587?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-134135587-blog-135914430.235^v43^pc_blog_bottom_relevance_base9&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=4">参考图片</a></p>

<pre><code class="language-mermaid">mindmap
  root((CKS考试范围))
    集群安全配置
      API Server安全
      kubelet配置
      内核强化
    系统加固
      最小权限原则
      升级与补丁
      AppArmor配置
    容器安全
      镜像扫描
      运行时安全
      资源限制
    供应链安全
      镜像签名
      准入控制
      RBAC配置
    监控与审计
      审计日志
      事件监控
      威胁检测
</code></pre>

<h2 id="核心知识点">核心知识点</h2>
<p>集群强化（15% ）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>限制访问Kubernetes API
使用基于角色的访问控制来最小化暴露
谨慎使用服务帐户，例如禁用默认设置，减少新创建帐户的权限
经常更新Kubernetes
</code></pre></div></div>

<p>系统强化 （10% ）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>最小化主机操作系统的大小(减少攻击面)
使用最小权限标识和访问管理
最小化对网络的外部访问
适当使用内核强化工具，如AppArmor, seccomp
</code></pre></div></div>

<p>微服务漏洞最小化（20%）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>使用适当的pod安全标准
管理Kubernetes机密
理解并实现隔离技术（多租户、沙盒容器等）
使用Cilium实现Pod-to-Pod加密
</code></pre></div></div>

<p>供应链安全(20%)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>最小化基本图像占用空间
了解您的供应链（例如，SBOM、CI/CD、工件存储库）
保护您的供应链（允许的注册中心、签名和验证工件等）。
执行用户工作负载和容器映像的静态分析（例如Kubesec， KubeLinter)
</code></pre></div></div>

<p>监控、日志记录和运行时安全（20%）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>执行行为分析以检测恶意活动
检测物理基础设施、应用程序、网络、数据、用户和工作负载中的威胁
调查并识别攻击阶段和环境中的不良参与者
确保容器在运行时的不变性
使用Kubernetes审计日志监控访问
</code></pre></div></div>

<p>CKS考试介绍	
01 kube-bench 修复不安全项	有kube-apiserver、etcd和kubelet，要记住3个文件对应的路径
02 Pod 指定 ServiceAccount	注意 automountServiceAccountToken: false
03默认网络策略	ingress + egress 或单个
04 RBAC - RoleBinding	熟悉命令
05[易错]日志审计log audit	参考官网即可
06 创建 Secret	前面2个命令行，最后第三问参考官方文档
07 Dockerfile 检测	CMD前的root才要换成nobody，删除SYS_ADMIN，确保 privileged=false
08 沙箱运行容器 gVisor	创建完runtimeClass之后3个deployment都要改，改完Pod会重建
09容器安全，删除特权 Pod	要删除特权和绑有卷的pod，privileged=true 和 带 hostPath 的
10 网络策略 NetworkPolicy	有两个条件，所有的两个from，第二个from的podSelector不能加横线(-)
11 Trivy 扫描镜像安全漏洞	送分题，但扫描比较花时间，要注意的是-s 后不能加引号
12 AppArmor	不是很好理解，涉及到linux核心知识，应试时照着步骤多做几遍记住就行
13 Sysdig &amp; falco	要熟悉sysdig的用法，不记得的时候要多看帮助文档
14启用API server 认证	ssh到master01找到对应的字段改掉，最后删掉匿名的clusterrolebinding就OK了
15TLS 安全配置	有较大的变化，仅供参考
16ImagePolicyWebhook 容器镜像扫描	容器镜像扫描 需要理解准入控制器是一个插件系统，配置好 kube-apiserver</p>

<h3 id="1-集群强化-cluster-hardening">1. 集群强化 (Cluster Hardening)</h3>

<h4 id="11-rbac配置">1.1 RBAC配置</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">// 示例</span><span class="pi">:</span> <span class="s">创建只读权限的Role</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Role</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">pod-reader</span>
<span class="na">rules</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">"</span><span class="pi">]</span>
  <span class="na">resources</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">pods"</span><span class="pi">]</span>
  <span class="na">verbs</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">get"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">list"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">watch"</span><span class="pi">]</span>
</code></pre></div></div>

<p>绑定到 Pod 的 ServiceAccount 的 Role 授予过度宽松的权限。完成以下项目以减少权限集。
Task
一个名为 web-pod 的现有 Pod 已在 namespace db 中运行。
编辑绑定到 Pod 的 ServiceAccount service-account-web 的现有 Role，仅允许只对 services 类型的资源执行 get 操作。
在 namespace db 中创建一个名为 role-2 ，并仅允许只对 namespaces 类型的资源执行 delete 操作的新 Role。
创建一个名为 role-2-binding 的新 RoleBinding，将新创建的 Role 绑定到 Pod 的 ServiceAccount。
注意：请勿删除现有的 RoleBinding</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">### 查询 sa 对应的 role 名称（假设是 role-1）</span>
<span class="s">kubectl get rolebinding -n db -oyaml | grep 'service-account-web' -B </span><span class="m">10</span>  <span class="c1">#通过rolebanding找到对应的role名称</span>

<span class="c1">### 修改 role 清单文件（仅允许对 services 类型的资源执行 get 操作）</span>
<span class="s">kubectl edit role -n db role-1</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Role</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">role-1</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">db</span>
  <span class="na">resourceVersion</span><span class="pi">:</span> <span class="s2">"</span><span class="s">9528"</span>
<span class="na">rules</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span>        <span class="err">	</span><span class="c1">#为默认的核心组</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">"</span>
  <span class="na">resources</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">services</span><span class="err">			</span><span class="s">#只给services资源授权</span>
  <span class="na">verbs</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">get</span><span class="err">				</span><span class="s">#具体的权限</span>
    
<span class="c1">### 创建新角色 role-2（仅允许只对 namespaces 类型的资源执行 delete 操作）</span>
<span class="s">kubectl create role role-2 -n db --verb=delete --resource=namespaces</span>


<span class="c1">### 创建 rolebinding，并绑定到 sa 上</span>
<span class="s">kubectl create rolebinding role-2-binding --role=role-2 --serviceaccount=db:service-account-web</span>
</code></pre></div></div>

<h4 id="12-网络策略">1.2 网络策略</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">// 示例</span><span class="pi">:</span> <span class="s">默认拒绝所有入站流量</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default-deny-ingress</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Ingress</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">denypolicy</span>          <span class="c1">#修改名称以及NS即可</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">testing</span>        <span class="c1">#官网复制，新增字段</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Ingress</span>
  <span class="pi">-</span> <span class="s">Egress</span>
</code></pre></div></div>

<blockquote>
  <p>namespace: test-a 允许访问 namespace: test-b ,其他不允许访问，也不允许被访问</p>
</blockquote>

<p>首先需要给命名空间添加标签（如果没有）：</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl label namespace test-a kubernetes.io/metadata.name<span class="o">=</span>test-a
kubectl label namespace test-b kubernetes.io/metadata.name<span class="o">=</span>test-b
</code></pre></div></div>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 配置 test-a 命名空间的网络策略</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">allow-test-b-only</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">test-a</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>  <span class="c1"># 应用到所有Pod</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Egress</span>
  <span class="pi">-</span> <span class="s">Ingress</span>
  <span class="na">egress</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">to</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">namespaceSelector</span><span class="pi">:</span>
        <span class="na">matchLabels</span><span class="pi">:</span>
          <span class="na">kubernetes.io/metadata.name</span><span class="pi">:</span> <span class="s">test-b</span>
  <span class="na">ingress</span><span class="pi">:</span> <span class="pi">[]</span>  <span class="c1"># 空列表表示拒绝所有入站流量</span>

<span class="nn">---</span>
<span class="c1"># 配置 test-b 命名空间的网络策略</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">allow-test-a-only</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">test-b</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>  <span class="c1"># 应用到所有Pod</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Ingress</span>
  <span class="pi">-</span> <span class="s">Egress</span>
  <span class="na">ingress</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">from</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">namespaceSelector</span><span class="pi">:</span>
        <span class="na">matchLabels</span><span class="pi">:</span>
          <span class="na">kubernetes.io/metadata.name</span><span class="pi">:</span> <span class="s">test-a</span>
  <span class="na">egress</span><span class="pi">:</span> <span class="pi">[]</span>  <span class="c1"># 空列表表示拒绝所有出站流量</span>
</code></pre></div></div>
<blockquote>
  <p>namespace：test-a 允许访问 namespace: test-b ，其他不允许访问，允许被访问</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 配置 test-a 命名空间的网络策略</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">test-a-policy</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">test-a</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>  <span class="c1"># 应用到所有Pod</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Egress</span>
  <span class="na">egress</span><span class="pi">:</span>  <span class="c1"># 只允许访问 test-b</span>
  <span class="pi">-</span> <span class="na">to</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">namespaceSelector</span><span class="pi">:</span>
        <span class="na">matchLabels</span><span class="pi">:</span>
          <span class="na">kubernetes.io/metadata.name</span><span class="pi">:</span> <span class="s">test-b</span>

<span class="nn">---</span>
<span class="c1"># 配置 test-b 命名空间的网络策略</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">test-b-policy</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">test-b</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>  <span class="c1"># 应用到所有Pod</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Ingress</span>
  <span class="na">ingress</span><span class="pi">:</span>  <span class="c1"># 只允许来自 test-a 的访问</span>
  <span class="pi">-</span> <span class="na">from</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">namespaceSelector</span><span class="pi">:</span>
        <span class="na">matchLabels</span><span class="pi">:</span>
          <span class="na">kubernetes.io/metadata.name</span><span class="pi">:</span> <span class="s">test-a</span>
</code></pre></div></div>

<blockquote>
  <p>namespace：test-a 不允许访问所有 namespace，其他不允许被访问</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 配置 test-a 命名空间的网络策略</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">NetworkPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">deny-all-egress</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">test-a</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span> <span class="pi">{}</span>  <span class="c1"># 应用到所有Pod</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Egress</span>
  <span class="pi">-</span> <span class="s">Ingress</span>
  <span class="na">egress</span><span class="pi">:</span> <span class="pi">[]</span>  <span class="c1"># 空列表表示拒绝所有出站流量</span>
  <span class="na">ingress</span><span class="pi">:</span> <span class="pi">[]</span>  <span class="c1"># 空列表表示拒绝所有入站流量</span>
</code></pre></div></div>

<p>Task
创建一个名为 pod-restriction 的 NetworkPolicy 来限制对在 namespace dev-team 中运行的 Pod products-service 的访问。
只允许以下 Pod 连接到 Pod products-service：
1.namespace qaqa 中的 Pod
2.位于任何 namespace，带有标签 environment: testing 的 Pod
注意：确保应用 NetworkPolicy。</p>

<p>这个networkPolicy创建的时候需要指定namespace是dev-team，名称是pod-restriction</p>

<p>由于是允许其它pod连接到Pod products-service，因此，策略应该是ingress，也就是入站策略</p>

<p>入站策略指定了两个范围一个是namespace为qaqa（由于网络策略是基于标签的，因此，本题需要查看namespace qaqa的标签），一个是带有指定标签envirnment:testing的pod，因此，该策略需要两个from</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">kubectl get ns qaqa --show-labels</span>      <span class="c1">#查看ns标签</span>
<span class="s">kubectl get po products-service -n dev-team --show-labels</span>     <span class="c1">#查询Pod products-service的标签</span>


<span class="s">vi /cks/net/po.yaml</span>
<span class="s">根据官网，修改为如下内容：</span>
<span class="s">……</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">pod-restriction </span><span class="err">		</span><span class="s">#修改</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">dev-team </span><span class="err">			</span><span class="s">#修改</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">podSelector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">environment</span><span class="pi">:</span> <span class="s">testing</span>    <span class="c1">#根据题目要求的标签修改，这个写的是 Pod products-service 的标签</span>
  <span class="na">policyTypes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">Ingress </span><span class="err">			</span><span class="s">#注意，这里只写 - Ingress，不要将 - Egress 也复制进来！</span>
  <span class="na">ingress</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">from</span><span class="pi">:</span>     <span class="c1">#第一个 from</span>
      <span class="pi">-</span> <span class="na">namespaceSelector</span><span class="pi">:</span>
          <span class="na">matchLabels</span><span class="pi">:</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">qaqa</span>         <span class="c1">#命名空间有 name: qaqa 标签的</span>
    <span class="pi">-</span> <span class="na">from</span><span class="pi">:</span>     <span class="c1">#第二个 from</span>
      <span class="pi">-</span> <span class="na">namespaceSelector</span><span class="pi">:</span> <span class="pi">{}</span>       <span class="c1">#修改为这样，所有命名空间</span>
        <span class="na">podSelector</span><span class="pi">:</span>                <span class="c1">#注意，这个 podSelector 前面的“-” 要删除，换成空格，空格对齐要对。（很重要）</span>
          <span class="na">matchLabels</span><span class="pi">:</span>
          <span class="na">environment</span><span class="pi">:</span> <span class="s">testing</span>       <span class="c1">#有 environment: testing 标签的 Pod</span>
</code></pre></div></div>
<p><img src="c64eb10abb5985b35c333876cbf9b90d.png" alt="alt text" /></p>

<h4 id="13-kube-bench-集群安全">1.3 kube-bench 集群安全</h4>
<p>针对 kubeadm 创建的 cluster 运行 CIS 基准测试工具时，发现了多个必须立即解决的问题。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kube-bench run <span class="nt">--targets</span><span class="o">=</span>master
kube-bench run <span class="nt">--targets</span><span class="o">=</span>node
kube-bench run <span class="nt">--targets</span><span class="o">=</span>etcd

千万不要在/etc/kubernetes/下备份，可能会导致异常，可以备份到/tmp或者其他目录下。

kubectl get node <span class="nt">-o</span> wide       
ssh master01

1.kube-apiserver配置文件的修改
修改之前，备份一下配置文件。
<span class="nb">mkdir </span>bak1
<span class="nb">cp</span> /etc/kubernetes/manifests/kube-apiserver.yaml bak1/

vim /etc/kubernetes/manifests/kube-apiserver.yaml
<span class="c">#修改、添加、删除相关内容   1.28没考 也需要检查</span>
<span class="c">#修改 authorization-mode，注意 Node 和 RBAC 之间的符号是英文状态的逗号，而不是点。</span>
 - <span class="nt">--authorization-mode</span><span class="o">=</span>Node,RBAC
<span class="c">#删除 insecure-bind-address，考试中，有可能本来就没写这行。</span>
 - <span class="nt">--insecure-bind-address</span><span class="o">=</span>0.0.0.0
 
 
1.kubelet配置文件的修改
修改之前，备份一下配置文件。
<span class="nb">mkdir </span>bak1
<span class="nb">cp</span> /var/lib/kubelet/config.yaml bak1/

vim /var/lib/kubelet/config.yaml
修改
apiVersion: kubelet.config.k8s.io/v1beta1
authentication:
 anonymous:  <span class="c">#修改 anonymous 下的，将 true 改为 false</span>
 enabled: <span class="nb">false</span>  <span class="c">#改为 false</span>
 webhook:
 cacheTTL: 0s
 enabled: <span class="nb">true</span>   <span class="c">#这个 webhook 下的 true 不要改</span>
 x509:
 clientCAFile: /etc/kubernetes/pki/ca.crt
authorization:   <span class="c">#修改 authorization 下的</span>
 mode: Webhook   <span class="c">#改为 Webhook  注意首字母大写</span>
 webhook:
……
<span class="c">#编辑完后重新加载配置文件，并重启 kubelet</span>
systemctl daemon-reload
systemctl restart kubelet.service

3，etcd配置文件的修改
修改之前，备份一下配置文件。
<span class="nb">mkdir </span>bak1
<span class="nb">cp</span> /etc/kubernetes/manifests/etcd.yaml bak1/

vim /etc/kubernetes/manifests/etcd.yaml
修改
 - <span class="nt">--client-cert-auth</span><span class="o">=</span><span class="nb">true</span> <span class="c">#修改为 true</span>

修改完成后，等待 5 分钟，再检查一下所有 pod，确保模拟环境里的所有 pod 都正常。
kubectl get pod <span class="nt">-A</span>
</code></pre></div></div>

<h4 id="14-pod-指定-serviceaccount">1.4 Pod 指定 ServiceAccount</h4>

<p>Task</p>

<p>在现有 namespace qa 中创建一个名为 backend-sa 的新 ServiceAccount， 确保此 ServiceAccount 不自动挂载 API 凭据。
使用 /cks/sa/pod1.yaml 中的清单文件来创建一个 Pod。
最后，清理 namespace qa 中任何未使用的 ServiceAccount。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">### 创建 ServiceAccount</span>
<span class="s">kubectl create sa backend-sa -n qa --dry-run=client -o yaml &gt;2-sa.yaml</span>

<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
<span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">backend-sa</span> <span class="c1">#修改 name</span>
 <span class="na">namespace</span><span class="pi">:</span> <span class="s">qa</span> <span class="c1">#注意添加 namespace</span>
<span class="na">automountServiceAccountToken</span><span class="pi">:</span> <span class="no">false</span> <span class="c1">#修改为 false，表示不自动挂载 secret  注意和metadata同级</span>


<span class="s">kubectl run nginx --image=nginx --dry-run=client -n qa -o yaml &gt;  /cks/sa/pod1.yaml</span>
<span class="c1">### 编辑 Pod 使用新创建的 serviceaccount</span>
<span class="s">vim /cks/sa/pod1.yaml</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">creationTimestamp</span><span class="pi">:</span> <span class="no">null</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">run</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">qa</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">backend-sa</span>   <span class="c1">#新增之前创建的sa</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">resources</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">dnsPolicy</span><span class="pi">:</span> <span class="s">ClusterFirst</span>
  <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">Always</span>
<span class="na">status</span><span class="pi">:</span> <span class="pi">{}</span>

<span class="c1">### 应用清单文件</span>
<span class="s">kubectl apply -f /cks/9/pod9.yaml</span>

<span class="c1">### 把除了 backend-sa 的 serviceaccount 都删除  ##default的sa有待确认  删除了会自动生成</span>
<span class="s">kubectl get pod -n qa -o yaml|grep -i "serviceaccount:"</span>
<span class="s">kubectl get sa -n qa</span>
<span class="s">kubectl delete sa fraont-sa -n qa</span>
</code></pre></div></div>

<p><img src="08fa7f9bcb235c86b0ae412ec88bbf46.png" alt="alt text" /></p>

<h4 id="15-启用-api-server-认证">1.5 启用 API server 认证</h4>

<p>由 kubeadm 创建的 cluster 的 Kubernetes API 服务器，出于测试目的，
临时配置允许未经身份验证和未经授权的访问，授予匿名用户 cluster-admin 的访问权限.
Task
重新配置 cluster 的 Kubernetes APl 服务器，以确保只允许经过身份验证和授权的 REST 请求。
使用授权模式 Node,RBAC 和准入控制器 NodeRestriction。
删除用户 system:anonymous 的 ClusterRoleBinding 来进行清理。
注意：所有 kubectl 配置环境/文件也被配置使用未经身份验证和未经授权的访问。
你不必更改它，但请注意，一旦完成 cluster 的安全加固， kubectl 的配置将无法工作。
您可以使用位于 cluster 的 master 节点上，cluster 原本的 kubectl 配置文件
/etc/kubernetes/admin.conf ，以确保经过身份验证的授权的请求仍然被允许。</p>

<p>任务一 确保只有认证并且授权过的 REST 请求才被允许</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/kubernetes/manifests/kube-apiserver.yaml
- <span class="nt">--authorization-mode</span><span class="o">=</span>Node,RBAC <span class="c">#				注意，只保留 Node,RBAC 这两个。可能默认已经有了，但还是要检查确认一下。</span>
- <span class="nt">--enable-admission-plugins</span><span class="o">=</span>NodeRestriction 				<span class="c">#原先为 AlwaysAdmit，需要修改为 NodeRestriction。</span>

重启kubelet   <span class="c">#这一步是重点</span>
systemctl daemon-reload
systemctl restart kubelet
</code></pre></div></div>
<p>任务二 删除题目要求的角色绑定</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get clusterrolebinding <span class="nt">-o</span> yaml | <span class="nb">grep </span>system:anonymous    <span class="c">#查看所有的clusterrole绑定的角色</span>
kubectl delete clusterrolebinding system:anonymous  <span class="c">#删除clusterrolebinding</span>
</code></pre></div></div>

<h3 id="2-系统加固">2. 系统加固</h3>

<h4 id="21-apparmor">2.1 AppArmor</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 安装AppArmor</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>apparmor-utils

<span class="c"># 创建配置文件</span>
<span class="nb">sudo </span>vim /etc/apparmor.d/container-profile

<span class="c"># 加载配置</span>
<span class="nb">sudo </span>apparmor_parser <span class="nt">-r</span> /etc/apparmor.d/container-profile
</code></pre></div></div>
<p>Task
在 cluster 的工作节点 node02 上，实施位于 /etc/apparmor.d/nginx_apparmor 的现有 APPArmor 配置文件。
编辑位于 /cks/KSSH00401/nginx-deploy.yaml 的现有清单文件以应用 AppArmor 配置文件。
最后，应用清单文件并创建其中指定的 Pod 。
请注意，考试时，考题里已表明 APPArmor 在工作节点上，所以你需要 ssh 到开头写的工作节点上。</p>

<p>确定/cks/KSSH00401/nginx-deploy.yaml是部署在工作节点的。</p>

<p>apparmor等于centos系统的selinux，因此，我们首先应该是查看位于工作节点的/etc/apparmor.d/nginx_apparmor 这个文件，确定次文件是正常的后，将apparmor规则加载到内核，然后修改/cks/KSSH00401/nginx-deploy.yaml这个文件，增加一个注解container.apparmor.security.beta.kubernetes.io/podx: localhost/nginx-profile-3指定到apparmor的名称，最后应用此部署文件即可。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 切换到 node02 的 root 下
ssh node02
<span class="nb">sudo</span> <span class="nt">-i</span>

2 切换到 apparmor 的目录，并检查配置文件
<span class="nb">cd</span> /etc/apparmor.d/
vi /etc/apparmor.d/nginx_apparmor

注意，nginx-profile-3 这一行要注释掉，但要确保 profile nginx-profile-3 这一行没有注释。
<span class="c">#include &lt;tunables/global&gt;</span>
profile nginx-profile-3 <span class="nv">flags</span><span class="o">=(</span>attach_disconnected<span class="o">)</span> <span class="o">{</span> <span class="c">#这句是正确的配置，不要修改。profile 后面的 nginx-profile-3 为 apparmor 策略模块的名字。</span>
 <span class="c">#include &lt;abstractions/base&gt;</span>
 file,
……
3 执行 apparmor 策略模块
没有 <span class="nb">grep </span>到，说明没有启动。
apparmor_status | <span class="nb">grep </span>nginx-profile-3
加载启用这个配置文件
apparmor_parser <span class="nt">-q</span> /etc/apparmor.d/nginx_apparmor    <span class="c">#2种方法都可以</span>
apparmor_parser <span class="nt">-r</span> /etc/apparmor.d/<span class="k">*</span>
<span class="c"># 再次检查有结果了</span>
apparmor_status | <span class="nb">grep </span>nginx
显示如下内容
nginx-profile-3
（注意！注意！考试时，这个文件是在默认登录的终端那个初始节点上的，而不是在这个 work 节点的。）
（对应模拟环境，就是在 node01 上，所以需要 <span class="nb">exit </span>退回来。）
4 修改 pod 文件
vi /cks/KSSH00401/nginx-deploy.yaml
修改如下内容
……
metadata:
  name: podname
 <span class="c">#添加 annotations，kubernetes.io/podx 名字和 containers 下的名字一样即可，nginx-profile-3 为前面在 worker node02 上执行的 apparmor 策略模块的名字。</span>
  annotations:
    container.apparmor.security.beta.kubernetes.io/podx: localhost/nginx-profile-3
spec:
  containers:
  - image: busybox
    imagePullPolicy: IfNotPresent
    name: podx 		<span class="c">#这个就是 containers 下的名字，为 podx</span>
    <span class="nb">command</span>: <span class="o">[</span> <span class="s2">"sh"</span>, <span class="s2">"-c"</span>, <span class="s2">"echo 'Hello AppArmor!' &amp;&amp; sleep 1h"</span> <span class="o">]</span>
……
创建
kubectl apply <span class="nt">-f</span> /cks/KSSH00401/nginx-deploy.yaml
kubectl <span class="nb">exec </span>podx <span class="nt">--</span> <span class="nb">touch</span> /tmp/test       <span class="c">#检查，写入文件会报错</span>
</code></pre></div></div>

<p><img src="83af92fe0b8eebcc987df7e7b3be20bc.png" alt="alt text" /></p>

<p><a href="https://kubernetes.io/zh-cn/docs/tutorials/security/apparmor/">apparmor</a></p>

<ol>
  <li>为什么要配置 AppArmor
    <ul>
      <li>安全增强</li>
    </ul>
  </li>
</ol>

<p>提供额外的安全层，限制容器的权限
防止容器逃逸和提权攻击
减少攻击面，限制系统资源访问</p>
<ul>
  <li>最小权限原则</li>
</ul>

<p>确保容器只能访问必需的资源
限制不必要的系统调用
降低安全风险</p>
<ol>
  <li>工作原理
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>graph TD
 A[应用程序] --&gt;|系统调用| B[AppArmor]
 B --&gt;|检查策略| C[策略规则]
 B --&gt;|审计日志| D[日志系统]
 B --&gt;|允许/拒绝| E[内核]
</code></pre></div>    </div>
  </li>
</ol>

<p>核心机制</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># AppArmor 配置示例</span>
profile docker-nginx <span class="nv">flags</span><span class="o">=(</span>attach_disconnected,mediate_deleted<span class="o">)</span> <span class="o">{</span>
  <span class="c"># 基础规则集</span>
  <span class="c">#include &lt;abstractions/base&gt;</span>
  
  <span class="c"># 文件访问规则</span>
  /var/log/nginx/<span class="k">*</span> w,
  /etc/nginx/nginx.conf r,
  
  <span class="c"># 网络访问规则</span>
  network inet tcp,
  
  <span class="c"># 能力限制</span>
  deny capability sys_admin,
  deny capability sys_module,
<span class="o">}</span>
</code></pre></div></div>

<p>强制访问控制</p>
<ul>
  <li>基于预定义的配置文件</li>
  <li>实时监控和拦截系统调用</li>
  <li>细粒度的权限控制</li>
</ul>

<ol>
  <li>主要应用场景
容器安全
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Kubernetes Pod 配置示例</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">annotations</span><span class="pi">:</span>
<span class="err"> </span><span class="na">container.apparmor.security.beta.kubernetes.io/nginx</span><span class="pi">:</span> <span class="s">localhost/docker-nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
 <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>Web服务器保护</p>

<p>限制 Nginx/Apache 访问范围
保护敏感文件和目录
控制网络访问权限</p>

<p>数据库安全</p>
<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># MySQL AppArmor 配置示例
</span><span class="n">profile</span> <span class="n">mysql</span> <span class="n">flags</span>=(<span class="n">attach_disconnected</span>) {
  /<span class="n">var</span>/<span class="n">lib</span>/<span class="n">mysql</span>/ <span class="n">r</span>,
  /<span class="n">var</span>/<span class="n">lib</span>/<span class="n">mysql</span>/** <span class="n">rwk</span>,
  /<span class="n">var</span>/<span class="n">log</span>/<span class="n">mysql</span>/ <span class="n">r</span>,
  /<span class="n">var</span>/<span class="n">log</span>/<span class="n">mysql</span>/* <span class="n">rw</span>,
}
</code></pre></div></div>
<p>多租户环境
隔离不同租户的应用
防止资源互相干扰
确保数据安全性</p>

<ol>
  <li>实施建议
配置管理
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 常用 AppArmor 命令</span>
aa-status                     <span class="c"># 查看状态</span>
aa-complain /etc/apparmor.d/<span class="k">*</span> <span class="c"># 设置警告模式</span>
aa-enforce /etc/apparmor.d/<span class="k">*</span>  <span class="c"># 设置强制模式</span>
</code></pre></div>    </div>
    <p>监控和审计</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 日志检查</span>
<span class="nb">tail</span> <span class="nt">-f</span> /var/log/syslog | <span class="nb">grep </span>audit
<span class="nb">grep </span>audit /var/log/kern.log
</code></pre></div>    </div>
    <p>最佳实践
从宽松模式开始
逐步收紧权限
定期审查和更新策略</p>
  </li>
  <li>性能考虑
5.1 资源开销</li>
</ol>

<p>轻量级实现
  最小化性能影响
  可预测的行为
5.2 优化建议</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 性能优化配置</span>
sysctl <span class="nt">-w</span> kernel.perf_event_paranoid<span class="o">=</span>1
sysctl <span class="nt">-w</span> kernel.kptr_restrict<span class="o">=</span>0
</code></pre></div></div>
<p>通过合理配置 AppArmor，可以显著提高系统安全性，同时保持良好的性能和可用性。在容器化环境中，AppArmor 是实现深度防御策略的重要组件。</p>

<h4 id="22-securitycontext配置">2.2 SecurityContext配置</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">security-context-demo</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">securityContext</span><span class="pi">:</span>
    <span class="na">runAsNonRoot</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">runAsUser</span><span class="pi">:</span> <span class="m">1000</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">sec-ctx-demo</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span> <span class="s2">"</span><span class="s">sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-c"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">sleep</span><span class="nv"> </span><span class="s">1h"</span> <span class="pi">]</span>
</code></pre></div></div>
<p><a href="https://kubernetes.io/zh-
cn/docs/tasks/configure-pod-container/security-context/ “为 Pod 或容器配置安全上下文 |
Kubernetes”">为 Pod 或容器配置安全上下文 | Kubernetes</a></p>

<p>Task:
按照如下要求修改 sec-ns 命名空间里的 Deployment secdep
一、用 ID 为 30000 的用户启动容器（设置用户 ID 为: 30000）
二、不允许进程获得超出其父进程的特权（禁止 allowPrivilegeEscalation）
三、以只读方式加载容器的根文件系统（对根文件的只读权限）</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="na">securityContext</span><span class="pi">:</span>
        <span class="na">allowPrivilegeEscalation</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">readOnlyRootFilesystem</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>
<p><img src="de8a1975476aa526e09a559ed1e72245.png" alt="alt text" /></p>

<p>可能–删除非无状态或非不可变的 pod
Task
检查在 namespace production 中运行的 Pod，并删除任何非无状态或非不可变的 Pod。
使用以下对无状态和不可变的严格解释：
a.能够在容器内存储数据的 Pod 的容器必须被视为非无状态的。
b.被配置为任何形式的特权 Pod 必须被视为可能是非无状态和非不可变的。
注意：你不必担心数据是否实际上已经存储在容器中。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">### 在命名空间 dev 中检查 running 状态的 pod</span>
kubectl get pods <span class="nt">-n</span> production | <span class="nb">grep </span>running

<span class="c">### 查看具有特权的 pod</span>
kubectl get pods <span class="nt">-n</span> production <span class="nt">-o</span> yaml | egrep <span class="nt">-i</span> <span class="s2">"privileged: true"</span>

<span class="c">### 查看具有 volume 的 pod</span>
kubectl get pods <span class="nt">-n</span> production <span class="nt">-o</span> yaml |grep <span class="s2">"volume"</span>

<span class="c">### 将查询到的具有特权和 volume 的 pod 都删除</span>
kubectl delete pods <span class="nt">-n</span> production pod名称
</code></pre></div></div>

<h4 id="23-dockerfile-检测">2.3 Dockerfile 检测</h4>

<p>Task
1.分析和编辑给定的 Dockerfile /cks/docker/Dockerfile（基于 ubuntu:16.04 镜像），
并修复在文件中拥有的突出的安全/最佳实践问题的两个指令。</p>

<p>2.分析和编辑给定的清单文件 /cks/docker/deployment.yaml ，
并修复在文件中拥有突出的安全/最佳实践问题的两个字段。</p>

<p>注意：请勿添加或删除配置设置；只需修改现有的配置设置让以上两个配置设置都不再有安全/最佳实践问题。
注意：如果您需要非特权用户来执行任何项目，请使用用户 ID 65535 的用户 nobody 。
只修改即可，不需要创建</p>

<p>修改Ubuntu的版本为16.04，一般不使用root来运行容器，这里改为使用nobody</p>
<pre><code class="language-txt">&lt;1&gt; 修改 Dockerfile
vi /cks/docker/Dockerfile
1、仅将 CMD 上面的 USER root 修改为 USER nobody，不要改其他的
USER nobody
2、修改基础镜像为题目要求的 ubuntu:16.04
FROM ubuntu:16.04
</code></pre>
<p>标签改为一样的，需要确保三个标签一致。
安全上下文配置错误,只需要修改，无需部署</p>

<pre><code class="language-txt"> securityContext字段中: 
 (1)将 privileged 变为 False；
 (2)将 readOnlyRootFilesystem 变为 True ;runAsUser: 65535 #注意首字母大写
</code></pre>

<h4 id="24-沙箱运行容器-gvisor">2.4 沙箱运行容器 gVisor</h4>
<p>该 cluster 使用 containerd 作为 CRI 运行时。containerd 的默认运行时处理程序是 runc。
containerd 已准备好支持额外的运行时处理程序 runsc (gVisor)。
Task
使用名为 runsc 的现有运行时处理程序，创建一个名为 untrusted 的 RuntimeClass。
更新 namespace server 中的所有 Pod 以在 gVisor 上运行。
您可以在 /cks/gVisor/rc.yaml 中找到一个模版清单。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /cks/gVisor/rc.yaml
apiVersion: node.k8s.io/v1beta1
kind: RuntimeClass
metadata:
  name: untrusted   <span class="c"># 用来引用 RuntimeClass 的名字，RuntimeClass 是一个集群层面的资源</span>
handler: runsc      <span class="c"># 对应的 CRI 配置的名称</span>
创建
kubectl create <span class="nt">-f</span> /cks/gVisor/rc.yaml


2 将命名空间为 server 下的 Pod 引用 RuntimeClass。
考试时，3 个 Deployment 下有 3 个 Pod，修改 3 个 deployment 即可。
kubectl <span class="nt">-n</span> server get deployment
 
编辑 deployment
kubectl <span class="nt">-n</span> server edit deployments busybox-run
kubectl <span class="nt">-n</span> server edit deployments nginx-host
kubectl <span class="nt">-n</span> server edit deployments run-test

修改如下内容
 spec: <span class="c">#下面有 containers 这个字段的 spec。  这里需要找一下是否已经有这个字段了。</span>
   runtimeClassName: untrusted <span class="c">#添加这一行，注意空格对齐，保存会报错，忽略即可。</span>
   containers:
   - image: nginx:1.9
     imagePullPolicy: IfNotPresent
     name: run-test
编辑pod也同理

验证，进到pod里面执行 命令 demsg 或者uname <span class="nt">-a</span>查看内核
</code></pre></div></div>
<p><img src="5e6cda72d1c0b905fd85147b25237413.png" alt="alt text" /></p>

<h4 id="25-trivy-扫描镜像安全漏洞">2.5 Trivy 扫描镜像安全漏洞</h4>
<p>Task
使用 Trivy 开源容器扫描器检测 namespace kamino 中 Pod 使用的具有严重漏洞的镜像。
查找具有 High 或 Critical 严重性漏洞的镜像，并删除使用这些镜像的 Pod。
注意：Trivy 仅安装在 cluster 的 master 节点上，
在工作节点上不可使用。
你必须切换到 cluster 的 master 节点才能使用 Trivy。</p>

<p>master 节点才能使用 Trivy
kubectl describe pod -n kamino |grep “Image:”|awk ‘{print $2}’ &gt; 1.txt  #获取命名空间下的所有镜像
for i in <code class="language-plaintext highlighter-rouge">cat 1.txt</code>; do trivy image -s HIGH,CRITICAL $i &gt; $i.txt; done
kubectl delete pod xxx -n kamino</p>

<table>
  <tbody>
    <tr>
      <td>trivy image nginx:1.19</td>
      <td>grep -iE ‘High</td>
      <td>Critical’  #也是可以用的</td>
    </tr>
  </tbody>
</table>

<h4 id="26-sysdig--falco">2.6 Sysdig &amp; falco</h4>
<p>Task：
使用运行时检测工具来检测 Pod tomcat123 单个容器中频发生成和执行的异常进程。
有两种工具可供使用：
    sysdig
    falco</p>

<p>注：这些工具只预装在 cluster 的工作节点 node02 上，不在 master 节点。
使用工具至少分析 30 秒 ，使用过滤器检查生成和执行的进程，将事件写到 /opt/KSR00101/incidents/summary 文件中，
其中包含检测的事件， 格式如下：
timestamp,uid/username,processName
保持工具的原始时间戳格式不变。</p>

<p>注：确保事件文件存储在集群的工作节点上。</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">### 需登录到工作节点操作</span>
ssh cka-node01

<span class="c">### 查看 sysdig 帮助</span>
sysdig <span class="nt">-h</span>

<span class="c">### 查看 sysdig 支持的元数据</span>
sysdig <span class="nt">-l</span> |grep <span class="nb">time
</span>sysdig <span class="nt">-l</span> |grep uid
sysdig <span class="nt">-l</span> |grep proc

<span class="c">### 查看指定容器ID</span>
crictl ps | <span class="nb">grep </span>tomcat

<span class="c">### -M 分析容器30秒，-p 指定事件保存格式，--cri 指定容器运行时，并且保存到指定文件路径中</span>
sysdig <span class="nt">-M</span> 30 <span class="nt">-p</span><span class="s2">"%evt.time,%user.uid,%proc.name"</span> <span class="nt">--cri</span> /run/containerd/containerd.sock container.id<span class="o">=</span>xxxxx <span class="o">&gt;</span> /opt/KSR00101/incidents/summary      <span class="c">#注意这里--cri 没有"=" 号</span>
<span class="c">###这道题目建议默写下来，节约大量时间</span>
sysdig <span class="nt">-M</span> 30 <span class="nt">-p</span><span class="s2">"%evt.time,%user.uid,%proc.name"</span> <span class="nt">--cri</span> /run/containerd/containerd.sock container.name<span class="o">=</span>tomcat123
sysdig <span class="nt">-M</span> 30 <span class="nt">-p</span><span class="s2">"%evt.time,%user.name,%proc.name"</span> <span class="nt">--cri</span> /run/containerd/containerd.sock container.name<span class="o">=</span>tomcat123
</code></pre></div></div>

<h4 id="27-imagepolicywebhook-容器镜像扫描">2.7 ImagePolicyWebhook 容器镜像扫描</h4>

<p>cluster上设置了容器镜像扫描器，但尚未完全集成到 cluster 的配置中。
完成后，容器镜像扫描器应扫描并拒绝易受攻击的镜像的使用。
Task
注意：你必须在 cluster 的 master 节点上完成整个考题，所有服务和文件都已被准备好并放置在该节点上。
给定一个目录 /etc/kubernetes/epconfig 中不完整的配置，
以及具有 HTTPS 端点 https://image-bouncer-webhook.default.svc:1323/image_policy 的功能性容器镜像扫描器：</p>
<ol>
  <li>启用必要的插件来创建镜像策略</li>
  <li>校验控制配置并将其更改为隐式拒绝（implicit deny）</li>
  <li>编辑配置以正确指向提供的 HTTPS 端点
最后，通过尝试部署易受攻击的资源 /cks/img/web1.yaml 来测试配置是否有效。</li>
</ol>

<p>image_policywebhook的部署是通过一个服务来完成的，https://image-bouncer-webhook.default.svc:1323/image_policy，考试的时候，这个服务是已经部署好的，因此，我们不需要关心这个服务是否部署，是以何种形式部署的，只需要知道该服务是可用的即可。</p>

<p>imagePolicyWebhook是需要apiserver引用的，因此，我们需要更改apiserver以插件的形式使用这个功能。</p>

<p>最后需要执行/cks/img/web1.yaml，如果此pod部署失败，表示imagePolicyWebhook插件启用成功。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>第 1 步 切换到 Master 的 root 下
ssh master01
<span class="nb">sudo</span> <span class="nt">-i</span>

第 2 步，编辑 admission_configuration.json（题目会给这个目录），修改 defaultAllow 为 <span class="nb">false</span>：
vi /etc/kubernetes/epconfig/admission_configuration.json       <span class="c">#修改准入控制器的json文件</span>
……
 <span class="s2">"denyTTL"</span>: 50,
 <span class="s2">"retryBackoff"</span>: 500,
 <span class="s2">"defaultAllow"</span>: <span class="nb">false</span> <span class="c">#将 true 改为 false</span>
……


第 3 步，编辑/etc/kubernetes/epconfig/kubeconfig.yml，添加 webhook server 地址：
操作前，先备份配置文件
<span class="nb">mkdir </span>bak16
<span class="nb">cp</span> /etc/kubernetes/epconfig/kubeconfig.yml bak16/

vi /etc/kubernetes/epconfig/kubeconfig.yml            <span class="c">#修改镜像扫描策略</span>
修改如下内容
……
 certificate-authority: /etc/kubernetes/epconfig/server.crt
 server: https://image-bouncer-webhook.default.svc:1323/image_policy   <span class="c">#添加 webhook server 地址</span>
 name: bouncer_webhook
……

第 4 步，编辑 kube-apiserver.yaml，从官网中引用 ImagePolicyWebhook 的配置信息：
操作前，先备份配置文件
<span class="nb">mkdir </span>bak16
<span class="nb">cp</span> /etc/kubernetes/manifests/kube-apiserver.yaml bak16/
vi /etc/kubernetes/manifests/kube-apiserver.yaml
在- <span class="nb">command</span>:下添加如下内容，注意空格要对齐（不建议放到最后，建议放置的位置详见下方截图）
 - <span class="nt">--enable-admission-plugins</span><span class="o">=</span>NodeRestriction,ImagePolicyWebhook
 - <span class="nt">--admission-control-config-file</span><span class="o">=</span>/etc/kubernetes/epconfig/admission_configuration.json <span class="c">#在 1.25 的考试中，默认这行已经添加了</span>
 
<span class="c"># 在 kube-apiserver.yaml 的 volumeMounts 增加</span>
 volumeMounts: <span class="c">#在 volumeMounts 下面增加 #注意，在 1.25 考试中，蓝色的内容可能已经有了</span>
   - mountPath: /etc/kubernetes/epconfig <span class="c">#建议紧挨着 volumeMounts 的下方增加</span>
     name: epconfig
     readOnly: <span class="nb">true</span>
<span class="c"># 在 kube-apiserver.yaml 的 volumes 增加</span>
 volumes: <span class="c">#在 volumes 下面增加 #注意，在 1.25 考试中，蓝色的内容可能已经有了，你只需要检查确认一下是否准确</span>
   - name: epconfig     <span class="c">#建议紧挨着 volumes 的下方增加</span>
     hostPath:
       path: /etc/kubernetes/epconfig
       <span class="nb">type</span>: DirectoryOrCreate       <span class="c">#如果你写的是目录，则是 DirectoryOrCreate，如果你写的是文件，则是 File</span>

第 5 步，重启 kubelet。
systemctl restart kubelet        <span class="c">#等待 3 分钟，等集群应用策略后，确保 kube-apiserver 是 running 的</span>

kubectl <span class="nt">-n</span> kube-system get pod   <span class="c">#通过尝试部署易受攻击的资源 /cks/img/web1.yaml 来测试配置是否有</span>

kubectl apply <span class="nt">-f</span> /cks/img/web1.yaml  <span class="c">#无法创建 pod，如下报错，表示成功。</span>
</code></pre></div></div>

<h3 id="3-供应链安全">3. 供应链安全</h3>
<pre><code class="language-mermaid">graph LR
    A[代码仓库] --&gt;|静态扫描| B[镜像构建]
    B --&gt;|漏洞扫描| C[镜像仓库]
    C --&gt;|签名验证| D[部署]
    D --&gt;|运行时安全| E[生产环境]
</code></pre>

<h4 id="31-配置审计日志">3.1 配置审计日志</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 修改API Server配置</span>
<span class="nb">sudo </span>vim /etc/kubernetes/manifests/kube-apiserver.yaml

<span class="c"># 添加以下参数</span>
spec:
  containers:
  - <span class="nb">command</span>:
    - kube-apiserver
    - <span class="nt">--audit-log-path</span><span class="o">=</span>/var/log/audit.log
    - <span class="nt">--audit-policy-file</span><span class="o">=</span>/etc/kubernetes/audit-policy.yaml
</code></pre></div></div>

<p>Task
在 cluster 中启用审计日志。为此，请启用日志后端，并确保：
   日志存储在 /var/log/kubernetes/audit-logs.txt
   日志文件能保留 10 天
   最多保留 2 个旧审计日志文件
/etc/kubernetes/logpolicy/sample-policy.yaml 提供了基本策略。它仅指定不记录的内容。
注意：基本策略位于 cluster 的 master 节点上。</p>

<p>编辑和扩展基本策略以记录：
   RequestResponse 级别的 persistentvolumes 更改
   namespace front-apps 中 configmaps 更改的请求体
   Metadata 级别的所有 namespace 中的 ConfigMap 和 Secret 的更改
此外，添加一个全方位的规则以在 Metadata 级别记录所有其他请求。
注意：不要忘记应用修改后的策略。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">audit.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Policy</span>
<span class="na">omitStages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s2">"</span><span class="s">RequestReceived"</span>
<span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">level</span><span class="pi">:</span> <span class="s">RequestResponse</span>
    <span class="na">resources</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">group</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
      <span class="na">resources</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">persistentvolumes"</span><span class="pi">]</span> 
  <span class="pi">-</span> <span class="na">level</span><span class="pi">:</span> <span class="s">Request</span>
    <span class="na">resources</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">group</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
      <span class="na">resources</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">configmaps"</span><span class="pi">]</span>   
    <span class="na">namespaces</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">front-apps"</span><span class="pi">]</span>
  <span class="pi">-</span> <span class="na">level</span><span class="pi">:</span> <span class="s">Metadata</span>
    <span class="na">resources</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">group</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
      <span class="na">resources</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">secrets"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">configmaps"</span><span class="pi">]</span>
  <span class="pi">-</span> <span class="na">level</span><span class="pi">:</span> <span class="s">Metadata</span>
    <span class="na">omitStages</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">RequestReceived"</span>
</code></pre></div></div>

<h4 id="32-实现pod安全策略">3.2 实现Pod安全策略</h4>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">policy/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">PodSecurityPolicy</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">restricted</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">privileged</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">seLinux</span><span class="pi">:</span>
    <span class="na">rule</span><span class="pi">:</span> <span class="s">RunAsAny</span>
  <span class="na">runAsUser</span><span class="pi">:</span>
    <span class="na">rule</span><span class="pi">:</span> <span class="s">MustRunAsNonRoot</span>
  <span class="na">fsGroup</span><span class="pi">:</span>
    <span class="na">rule</span><span class="pi">:</span> <span class="s">RunAsAny</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s1">'</span><span class="s">configMap'</span>
  <span class="pi">-</span> <span class="s1">'</span><span class="s">emptyDir'</span>
  <span class="pi">-</span> <span class="s1">'</span><span class="s">persistentVolumeClaim'</span>
</code></pre></div></div>

<h4 id="33-secret管理">3.3 Secret管理</h4>

<p>Task
在 namespace istio-system 中获取名为 db1-test 的现有 secret 的内容
将 username 字段存储在名为 /cks/sec/user.txt 的文件中，并将 password 字段存储在名为 /cks/sec/pass.txt 的文件中。
注意：你必须创建以上两个文件，他们还不存在。
注意：不要在以下步骤中使用/修改先前创建的文件，如果需要，可以创建新的临时文件。</p>

<p>在 istio-system namespace 中创建一个名为 db2-test 的新 secret，内容如下：
username : production-instance
password : KvLftKgs4aVH</p>

<p>最后，创建一个新的 Pod，它可以通过卷访问 secret db2-test ：
Pod 名称 secret-pod
Namespace istio-system
容器名 dev-container
镜像 nginx
卷名 secret-volume
挂载路径 /etc/secret</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get secret <span class="nt">-n</span> istio-system <span class="nt">-o</span> yaml
<span class="nb">echo </span>xxx | <span class="nb">base64</span> <span class="nt">-d</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /cks/sec <span class="o">&amp;&amp;</span> <span class="nb">touch</span> /cks/sec/user.txt <span class="o">&amp;&amp;</span> <span class="nb">echo </span>lady_killer9 <span class="o">&gt;</span> /cks/sec/user.txt
<span class="nb">touch</span> /cks/sec/pass.txt <span class="o">&amp;&amp;</span> <span class="nb">echo </span>123456 <span class="o">&gt;</span> /cks/sec/pass.txt
</code></pre></div></div>

<p>创建名为 db2-test 的 secret 使用题目要求的用户名和密码作为键值。注意要加命名空间。
注意，如果密码中有特殊字符（例如：$，\，*，= 和 !），需要加单引号来转义–from-literal=password=’G!Y*d$zDsb’这样。
kubectl create secret generic db2-test -n istio-system –from-literal=username=production-instance –from-literal=password=KvLftKgs4aVH</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>根据题目要求，创建 Pod 使用该 secret
vim k8s-secret.yaml
添加如下内容
apiVersion: v1
kind: Pod
metadata:
 name: secret-pod 		    <span class="c">#pod 名字</span>
 namespace: istio-system 	<span class="c">#命名空间</span>
spec:
 containers:
 - name: dev-container	 	<span class="c">#容器名字</span>
   image: nginx 	  	    <span class="c">#镜像名字</span>
   volumeMounts: 			<span class="c">#挂载路径</span>
   - name: secret-volume 		<span class="c">#卷名</span>
     mountPath: /etc/secret
     readOnly: <span class="nb">true
 </span>volumes:
 - name: secret-volume 		  <span class="c">#卷名</span>
   secret:
     secretName: db2-test 		<span class="c">#名为 db2-test 的 secret</span>
创建
kubectl apply <span class="nt">-f</span> k8s-secret.yaml

</code></pre></div></div>
<p><img src="e7d9d059a6b144a45d762616a181c593.png" alt="alt text" /></p>

<h4 id="34-tls-安全配置">3.4 TLS 安全配置</h4>
<p>Task
通过 TLS 加强 kube-apiserver 安全配置，要求
1、kube-apiserver 除了 VersionTLS13 及以上的版本可以使用，其他版本都不允许使用。
2、密码套件（Cipher suite）为 TLS_AES_128_GCM_SHA256
通过 TLS 加强 ETCD 安全配置，要求
1、密码套件（Cipher suite）为 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec</span> <span class="nt">-it</span> <span class="nt">-n</span> kube-system kube-apiserver-controlplane <span class="nt">--</span> kube-apiserver <span class="nt">-h</span>|grep tls


1 切换到 Master 的 root 下    <span class="c">#重要</span>
ssh master01
<span class="nb">sudo</span> <span class="nt">-i</span>

修改 kube-apiserver
修改之前，备份一下配置文件。
<span class="nb">mkdir </span>bak15
<span class="nb">cp</span> /etc/kubernetes/manifests/kube-apiserver.yaml bak15/
vim /etc/kubernetes/manifests/kube-apiserver.yaml
添加或修改相关内容，并保存（先检查一下，如果考试环境里已经给你这两条了，则你只需要修改即可）
 - <span class="nt">--tls-cipher-suites</span><span class="o">=</span>TLS_AES_128_GCM_SHA256
 - <span class="nt">--tls-min-version</span><span class="o">=</span>VersionTLS13


修改 etcd
修改之前，备份一下配置文件。
<span class="nb">mkdir </span>bak15
<span class="nb">cp</span> /etc/kubernetes/manifests/etcd.yaml bak15/
vim /etc/kubernetes/manifests/etcd.yaml
添加或修改相关内容，并保存
 - <span class="nt">--cipher-suites</span><span class="o">=</span>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256


systemctl daemon-reload
systemctl restart kubelet

重启etcd
systemctl restart etcd 
如果出现：Failed to restart etcd.service: Unit etcd.service not found.，可以查找kube-system下的etcd，例如
kubectl delete po etcd-controlplane <span class="nt">-n</span> kube-system

修改完成后，等待3分钟，等集群应用策略后，再检查所有 pod，特别是etcd和kube-apiserver两个pod，确保模拟环境是正常的。
kubectl get pod <span class="nt">-A</span>
kubectl <span class="nt">-n</span> kube-system get pod
ps <span class="nt">-ef</span>|grep etcd  <span class="c">#可以看看是否集成进去</span>

</code></pre></div></div>

<h2 id="学习路线">学习路线</h2>

<pre><code class="language-mermaid">graph TD
    A[基础知识] --&gt;|1-2周| B[集群配置]
    B --&gt;|2-3周| C[安全实践]
    C --&gt;|2-3周| D[真题练习]
    D --&gt;|1周| E[模拟考试]
    
    style A fill:#f9f,stroke:#333,stroke-width:4px
    style E fill:#bbf,stroke:#333,stroke-width:4px
</code></pre>

<h3 id="推荐学习资源">推荐学习资源</h3>

<ol>
  <li>Kubernetes官方文档</li>
  <li>CKS课程(Udemy)</li>
  <li>Killer.sh模拟考试</li>
  <li>GitHub实验项目</li>
</ol>

<h2 id="考试技巧">考试技巧</h2>

<ol>
  <li>时间管理
    <ul>
      <li>先做简单题</li>
      <li>标记难题待回顾</li>
      <li>预留检查时间</li>
    </ul>
  </li>
  <li>环境熟悉
    <ul>
      <li>善用kubectl自动补全</li>
      <li>掌握vim基本操作</li>
      <li>熟练使用Linux命令</li>
    </ul>
  </li>
  <li>常用命令速查</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看集群状态</span>
kubectl get nodes <span class="nt">-o</span> wide

<span class="c"># 查看安全上下文</span>
kubectl describe pod pod-name | <span class="nb">grep</span> <span class="nt">-A</span> 10 Security

<span class="c"># 检查网络策略</span>
kubectl get networkpolicies <span class="nt">-A</span>

<span class="c"># 审计日志查看</span>
<span class="nb">sudo tail</span> <span class="nt">-f</span> /var/log/audit.log
</code></pre></div></div>

<h2 id="实用工具清单">实用工具清单</h2>

<ol>
  <li>容器扫描
    <ul>
      <li>Trivy</li>
      <li>Clair</li>
      <li>Aqua</li>
    </ul>
  </li>
  <li>配置检查
    <ul>
      <li>kube-bench</li>
      <li>kubesec</li>
      <li>Polaris</li>
    </ul>
  </li>
  <li>运行时安全
    <ul>
      <li>Falco</li>
      <li>Tracee</li>
      <li>Kubearmor</li>
    </ul>
  </li>
</ol>

<h2 id="总结">总结</h2>

<p>CKS认证考试不仅考察Kubernetes的安全配置能力，更注重实际问题的解决能力。通过系统化的学习和大量实践，可以全面提升Kubernetes安全管理水平。</p>

<h3 id="知识图谱">知识图谱</h3>

<pre><code class="language-mermaid">mindmap
  root((Kubernetes安全))
    认证
      X509证书
      ServiceAccount
      OIDC
    授权
      RBAC
      Webhook
      Node
    安全上下文
      SecurityContext
      PodSecurityPolicy
    网络安全
      NetworkPolicy
      CNI插件
    数据安全
      Secret管理
      加密配置
      存储安全
</code></pre>

<h2 id="参考资料">参考资料</h2>

<ol>
  <li><a href="https://kubernetes.io/docs/concepts/security/">Kubernetes官方安全文档</a></li>
  <li><a href="https://github.com/cncf/curriculum">CKS考试大纲</a></li>
  <li><a href="https://kubernetes.io/docs/concepts/security/security-best-practices/">Kubernetes安全最佳实践</a></li>
</ol>

    </div>
  </article>
</div>

<style>
.doc-page {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem 1rem;
}

.doc-meta {
  display: flex;
  gap: 1.5rem;
  margin: 1.5rem 0;
  padding: 1rem 0;
  border-top: 1px solid #e1e4e8;
  border-bottom: 1px solid #e1e4e8;
  color: #6a737d;
  font-size: 0.9rem;
}

.doc-body {
  line-height: 1.7;
  margin-top: 2rem;
}

.doc-body h2 {
  margin-top: 2rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid #e1e4e8;
}

.doc-body h3 {
  margin-top: 1.5rem;
}

.doc-body code {
  background-color: #f6f8fa;
  padding: 0.2em 0.4em;
  border-radius: 3px;
  font-family: monospace;
}

.doc-body pre {
  background-color: #f6f8fa;
  padding: 1rem;
  border-radius: 6px;
  overflow-x: auto;
}
</style>
      </div>
    </main>
    
    <footer>
      <div class="container">
        <p>&copy; 2025 Pizicai's Tech Blog. All rights reserved.</p>
        <p>
          <a href="https://github.com/pizicaiman" target="_blank">GitHub</a> | 
          <a href="/about/">关于</a>
        </p>
      </div>
    </footer>
    
    <script>
      // 代码高亮
      document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      });
    </script>
  </body>
</html>